<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
<!--    <link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Crimson+Pro:ital,wght@0,200..900;1,200..900&family=Geist:wght@100..900&display=swap" rel="stylesheet">
 --><link rel="stylesheet" href="coloris/coloris.min.css" />
<script src="coloris/coloris.min.js"></script>   
   
    <title>Text Highlighter</title>
    <style>
        @font-face {
            font-family: 'Sahitya';
            src: url('./Sahitya-Regular.ttf') format('truetype');
            font-weight: normal;
            font-style: normal;
        }
        body {
             font-family: 'Sahitya', serif;
            background-color: #1B1B1B;
            color: #ffffff;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            padding: 1rem;
            box-sizing: border-box;
            margin: 0;
            -webkit-tap-highlight-color: transparent;
            font-size:20px;
            transition: background-color 0.3s, color 0.3s;
        }
        .theme-toggle {
            position: fixed;
            bottom: 15px;
            right: 15px;
            background: #333;
            border: none;
            border-radius: 50%;
            padding: 10px;
            cursor: pointer;
            z-index: 9999;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);
            transition: background 0.3s;
        }
        
        .theme-toggle:hover {
            background: #444;
        }
        
        .theme-toggle svg {
            display: block;
            width: 20px;
            height: 20px;
            fill: #fff;
        }
        
        .dark-mode {
            color: #1B1B1B;
            background-color: #fff;
        }
        .container {
            width: 100%;
            background-color: transparent;
            position: relative;
                        overflow-x: hidden;
                        
        }
        .content-paragraph{
            font-size:20px;
            line-height: 1.25; 
        }
        .highlight-toolbar {
            position: absolute;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background-color: #333;
            padding: 0.70rem 0.75rem;
            border-radius: 0.75rem;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2);
            opacity: 0;
            visibility: hidden;
            transform: translateY(10px);
            transition: opacity 0.1s ease-out, transform 0.1s ease-out, visibility 0.1s ease-out;
            z-index: 1000;
            cursor: move;
            user-select: none;
        }

        .highlight-toolbar.visible {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
            display: flex;
        }

        .highlight-toolbar button {
            background-color: #555;
            color: #fff;
            padding: 0.5rem 0.75rem;
            border-radius: 0.5rem;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out;
            display: flex;
            align-items: center;
            gap: 0.25rem;
            border: 0;
        }

        .highlight-toolbar button:hover {
            background-color: #777;
            transform: translateY(-1px);
        }

        .highlight-toolbar button:active {
            transform: translateY(0);
        }

        .color-palette {
            display: flex;
            gap: 0.35rem;
            margin-left: 0rem;
        }

        .color-option {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid transparent;
            transition: transform 0.1s ease-in-out, border-color 0.1s ease-in-out;
        }

        .color-option:hover {
            transform: scale(1.1);
            border-color: #fff;
        }

        .highlighted {
            padding: 0px 0;
            border-radius: 0.3rem;
            box-decoration-break: clone;
            -webkit-box-decoration-break: clone;
             
        }

        .underlined {
            text-decoration: underline;
            text-underline-offset: 3px;
            text-decoration-thickness: 2px;
        }

        .highlighted.active,
        .underlined.active {
            box-shadow: 0 0 0 2px #60a5fa;
            z-index: 1;
            position: relative;
        }

        .hidden {
            display: none !important;
        }

        p {
            line-height: 1.6;
        }
        .color-option.picker{
            background: url('radial.png');
            background-size:120%;                      /* <------ */
            background-repeat:   no-repeat;
            background-position: center;              
            border-radius: 20px;
        }
        .picker * {
            opacity: 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <p id="content-paragraph">
          </p>

        <div id="highlight-toolbar" class="highlight-toolbar">
            <button id="apply-highlight-btn" class="visible">
                <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 20 20"><path fill="currentColor" d="M4.5 2A1.5 1.5 0 0 0 3 3.5v3A1.5 1.5 0 0 0 4.5 8h11A1.5 1.5 0 0 0 17 6.5v-3A1.5 1.5 0 0 0 15.5 2zM6 11a2 2 0 0 1-2-2h12a2 2 0 0 1-2 2zm0 1h8v1.074a2 2 0 0 1-1.106 1.789l-6.17 3.085A.5.5 0 0 1 6 17.501z"/></svg>
                
            </button>
            <button id="apply-underline-btn" class="visible">
                <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24"><g fill="none"><path d="m12.593 23.258l-.011.002l-.071.035l-.02.004l-.014-.004l-.071-.035q-.016-.005-.024.005l-.004.01l-.017.428l.005.02l.01.013l.104.074l.015.004l.012-.004l.104-.074l.012-.016l.004-.017l-.017-.427q-.004-.016-.017-.018m.265-.113l-.013.002l-.185.093l-.01.01l-.003.011l.018.43l.005.012l.008.007l.201.093q.019.005.029-.008l.004-.014l-.034-.614q-.005-.018-.02-.022m-.715.002a.02.02 0 0 0-.027.006l-.006.014l-.034.614q.001.018.017.024l.015-.002l.201-.093l.01-.008l.004-.011l.017-.43l-.003-.012l-.01-.01z"/><path fill="currentColor" d="M18 18.5a1.5 1.5 0 0 1 .144 2.993L18 21.5H6a1.5 1.5 0 0 1-.144-2.993L6 18.5zm-1-16a1.5 1.5 0 0 1 1.493 1.356L18.5 4v7a6.5 6.5 0 0 1-12.996.233L5.5 11V4a1.5 1.5 0 0 1 2.993-.144L8.5 4v7a3.5 3.5 0 0 0 6.995.192L15.5 11V4A1.5 1.5 0 0 1 17 2.5"/></g></svg>
                
            </button>
            <button id="copy-btn" class="visible">
         
            <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path d="M7 9.667A2.667 2.667 0 0 1 9.667 7h8.666A2.667 2.667 0 0 1 21 9.667v8.666A2.667 2.667 0 0 1 18.333 21H9.667A2.667 2.667 0 0 1 7 18.333z"/><path d="M4.012 16.737A2 2 0 0 1 3 15V5c0-1.1.9-2 2-2h10c.75 0 1.158.385 1.5 1"/></g></svg>
            </button>
            
            <button id="delete-style-btn" class="hidden">
                <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24"><path fill="currentColor" d="M2.75 6.167c0-.46.345-.834.771-.834h2.665c.529-.015.996-.378 1.176-.916l.03-.095l.115-.372c.07-.228.131-.427.217-.605c.338-.702.964-1.189 1.687-1.314c.184-.031.377-.031.6-.031h3.478c.223 0 .417 0 .6.031c.723.125 1.35.612 1.687 1.314c.086.178.147.377.217.605l.115.372l.03.095c.18.538.74.902 1.27.916h2.57c.427 0 .772.373.772.834S20.405 7 19.979 7H3.52c-.426 0-.771-.373-.771-.833M11.607 22h.787c2.707 0 4.06 0 4.941-.863c.88-.864.97-2.28 1.15-5.111l.26-4.081c.098-1.537.147-2.305-.295-2.792s-1.187-.487-2.679-.487H8.23c-1.491 0-2.237 0-2.679.487s-.392 1.255-.295 2.792l.26 4.08c.18 2.833.27 4.248 1.15 5.112S8.9 22 11.607 22"/></svg>
                
            </button>
            <div class="color-palette" id="color-palette"></div>
        </div>
        
        <button class="theme-toggle" id="themeToggleBtn" aria-label="Toggle Theme">
            <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24">
                <path fill="#fff" d="M12 19a1 1 0 0 1 .993.883L13 20v1a1 1 0 0 1-1.993.117L11 21v-1a1 1 0 0 1 1-1m6.313-2.09l.094.083l.7.7a1 1 0 0 1-1.32 1.497l-.094-.083l-.7-.7a1 1 0 0 1 1.218-1.567zm-11.306.083a1 1 0 0 1 .083 1.32l-.083.094l-.7.7a1 1 0 0 1-1.497-1.32l.083-.094l.7-.7a1 1 0 0 1 1.414 0M4 11a1 1 0 0 1 .117 1.993L4 13H3a1 1 0 0 1-.117-1.993L3 11zm17 0a1 1 0 0 1 .117 1.993L21 13h-1a1 1 0 0 1-.117-1.993L20 11zM6.213 4.81l.094.083l.7.7a1 1 0 0 1-1.32 1.497l-.094-.083l-.7-.7A1 1 0 0 1 6.11 4.74zm12.894.083a1 1 0 0 1 .083 1.32l-.083.094l-.7.7a1 1 0 0 1-1.497-1.32l.083-.094l.7-.7a1 1 0 0 1 1.414 0M12 2a1 1 0 0 1 .993.883L13 3v1a1 1 0 0 1-1.993.117L11 4V3a1 1 0 0 1 1-1m0 5a5 5 0 1 1-4.995 5.217L7 12l.005-.217A5 5 0 0 1 12 7" />
            </svg>
        </button>

    </div>
<script>
    const slug = new URLSearchParams(window.location.search).get("slug");
const paragraph = document.getElementById("content-paragraph");

if (!slug) {
  paragraph.innerHTML = "No slug provided in URL.";
} else {
  // Everything else goes inside this else block
  const dbName = "OshoDiscourseDB";
  const storeName = "discourses";

  const openRequest = indexedDB.open(dbName, 1);

  openRequest.onupgradeneeded = function (e) {
    const db = e.target.result;
    if (!db.objectStoreNames.contains(storeName)) {
      db.createObjectStore(storeName, { keyPath: "slug" });
    }
  };

  openRequest.onsuccess = function (e) {
    const db = e.target.result;

    const tx = db.transaction(storeName, "readonly");
    const store = tx.objectStore(storeName);

    const getRequest = store.get(slug);

    getRequest.onsuccess = function () {
      const result = getRequest.result;

      if (result) {
        paragraph.innerHTML = result.description || "No description found (cached).";
      } else {
        fetchAndStoreSlug(db, slug);
      }
    };

    getRequest.onerror = function () {
      paragraph.innerHTML = "Error reading from offline storage.";
    };
  };

  openRequest.onerror = function () {
    paragraph.innerHTML = "Failed to open local database.";
  };

  function fetchAndStoreSlug(db, slug) {
    const apiUrl = `https://extremekrish.github.io/osho/discourse/${slug}.json`;

    fetch(apiUrl)
      .then((res) => {
        if (!res.ok) throw new Error("Network error");
        return res.json();
      })
      .then((data) => {
        const description = data.description;

        const tx = db.transaction(storeName, "readwrite");
        const store = tx.objectStore(storeName);
        store.put({ slug: slug, description: description });

        paragraph.innerHTML = description || "No description found (fresh).";
      })
      .catch((err) => {
        paragraph.innerHTML = "Error fetching content: " + err.message;
      });
  }
}



// MAIN FILE STARTS HERE

    const fileName = slug;
    
    const toggleBtn = document.getElementById('themeToggleBtn');
    toggleBtn.addEventListener('click', () => {
        document.body.classList.toggle('dark-mode');
    });

    const contentParagraph = document.getElementById('content-paragraph');
    const highlightToolbar = document.getElementById('highlight-toolbar');
    const applyHighlightBtn = document.getElementById('apply-highlight-btn');
    const copyBtn = document.getElementById('copy-btn');

    const applyUnderlineBtn = document.getElementById('apply-underline-btn');
    const deleteStyleBtn = document.getElementById('delete-style-btn');
    const colorPalette = document.getElementById('color-palette');

    const colors = ['#fde047', '#a7f3d0', '#bfdbfe', '#fecaca', '#dbeafe', '#fbcfe8'];
    let selectedColor = colors[0];
    let currentActiveStyledElement = null;
    const highlightsMap = new Map();
    const storedHighlightObj = {
      "highlight1": {
        "text": "Lorem ipsum dolor sit amet, consectetur adipiscing elit",
        "color": "#00ff00",
        "styleType": "highlight",
        "startOffset": 0,
        "endOffset": 55
      },
      "highlight2": {
        "text": "Phasellus euismod, nibh ut consequat pulvinar",
        "color": "#ff0000",
        "styleType": "underline",
        "startOffset": 158,
        "endOffset": 203
      }
    };
    
   const preHighlights = loadHighlightsFromStorage(fileName);


    // const preHighlights = [
    //     { text: "Lorem ipsum dolor sit amet, consectetur adipiscing elit", color: "#00ff00", styleType: "highlight", id: "highlight1" },
    //     { text: "Phasellus euismod, nibh ut consequat pulvinar", color: "#ff0000", styleType: "underline", id: "highlight2" }
    // ];

    function populateColorPalette() {
        colorPalette.innerHTML = ''; // clear previous palette
        
        colors.forEach(color => {
            const colorOption = document.createElement('div');
            colorOption.classList.add('color-option');
            colorOption.style.backgroundColor = color;
            colorOption.dataset.color = color;
            colorOption.addEventListener('click', () => {
                selectedColor = color;
                document.querySelectorAll('.color-option').forEach(opt => opt.style.borderColor = 'transparent');
                colorOption.style.borderColor = '#fff';
        
                if (currentActiveStyledElement) {
                    const type = currentActiveStyledElement.dataset.styleType;
                    if (type === 'highlight') {
                        currentActiveStyledElement.style.backgroundColor = selectedColor;
            
                        // 🔥 Add this block to ensure text color adjusts for highlight
                        const rgb = getRGB(selectedColor);
                        const luminance = getLuminance(rgb.r, rgb.g, rgb.b);
                        currentActiveStyledElement.style.color = luminance < 0.5 ? '#fff' : '#000';
            
                    } else if (type === 'underline') {
                        currentActiveStyledElement.style.textDecorationColor = selectedColor;
                        // leave text color unchanged
                    }
            
                    currentActiveStyledElement.dataset.color = selectedColor;
                    highlightsMap.set(currentActiveStyledElement.dataset.id, {
                        text: currentActiveStyledElement.textContent,
                        color: selectedColor,
                        styleType: type
                        //startOffset: getNodeOffset(currentActiveStyledElement),
                        //endOffset: getNodeOffset(currentActiveStyledElement) + currentActiveStyledElement.textContent.length
                    });
                    saveHighlightsToStorage(highlightsMap);
                }
            });
            
            colorPalette.appendChild(colorOption);
            Coloris({
              themeMode: 'dark',
              alpha: false,
              clearButton: false,
              closeButton: false
            });
        });
        
        // Add the color picker at the end
        const pickerDiv = document.createElement('div');
        pickerDiv.classList.add('color-option', 'picker');
        pickerDiv.innerHTML = '<input type="text" class="picker-input" data-coloris>';
        colorPalette.appendChild(pickerDiv);
        const pickerInput = document.querySelector('.picker-input');
        
        let lastColorUsed = '';
    
        pickerInput.addEventListener('input', (e) => {
            const liveColor = e.target.value;
            lastColorUsed = liveColor;
            selectedColor = liveColor; // 🔥 important to apply in next highlight
            applyColorToSelection(liveColor);
        });
    
        pickerInput.addEventListener('change', (e) => {
            const finalColor = e.target.value;
            selectedColor = finalColor;
            
            if (!colors.includes(finalColor)) {
                colors.unshift(finalColor);
                if (colors.length > 6) colors.pop();
                populateColorPalette();
            }
        });
    
        pickerInput.addEventListener('blur', () => {
            if (!colors.includes(lastColorUsed)) {
                colors.unshift(lastColorUsed);
                if (colors.length > 6) colors.pop();
                populateColorPalette(); // re-render
            }
        });
    
        const initialSelectedOption = document.querySelector(`.color-option[data-color="${selectedColor}"]`);
        if (initialSelectedOption) initialSelectedOption.style.borderColor = '#fff';
    }

    function getNodeOffset(node) {
        let offset = 0;
        let current = node;
        while (current.previousSibling) {
            current = current.previousSibling;
            if (current.nodeType === Node.TEXT_NODE) {
                offset += current.textContent.length;
            } else if (current.nodeType === Node.ELEMENT_NODE) {
                offset += current.textContent.length;
            }
        }
        return offset;
    }
    
    function loadHighlightsFromStorage() {
      const stored = localStorage.getItem(fileName);
      if (!stored) return [];
    
      const storedHighlightObj = JSON.parse(stored);
      return Object.entries(storedHighlightObj).map(([id, data]) => ({
        ...data,
        id
      }));
    }
    
    function saveHighlightsToStorage(highlightsMap) {
        const objToStore = Object.fromEntries(highlightsMap);
        localStorage.setItem(fileName, JSON.stringify(objToStore));
        console.log(JSON.stringify(Object.fromEntries(highlightsMap), null, 2));

    }



    function applyPreHighlights() {
        const text = contentParagraph.textContent;
        preHighlights.forEach(({ text: highlightText, color, styleType, id }) => {
            
            const startIndex = text.indexOf(highlightText);
            if (startIndex === -1) return;

            const range = document.createRange();
            let currentOffset = 0;
            let foundNode = null;
            let startNodeOffset = 0;

            const walker = document.createTreeWalker(contentParagraph, NodeFilter.SHOW_TEXT, null);
            while (walker.nextNode()) {
                const node = walker.currentNode;
                const nodeLength = node.textContent.length;
                if (currentOffset + nodeLength > startIndex) {
                    startNodeOffset = startIndex - currentOffset;
                    foundNode = node;
                    break;
                }
                currentOffset += nodeLength;
            }

            if (foundNode) {
                range.setStart(foundNode, startNodeOffset);
                range.setEnd(foundNode, startNodeOffset + highlightText.length);

                const span = document.createElement('span');
                span.style.color = 'inherit';
                span.dataset.styleType = styleType;
                span.dataset.color = color;
                span.dataset.id = id;
                if (styleType === 'highlight') {
                    span.classList.add('highlighted');
                    span.style.backgroundColor = color;
                    
                    const rgb = getRGB(color);
                    const luminance = getLuminance(rgb.r, rgb.g, rgb.b);
                    span.style.color = luminance < 0.5 ? '#fff' : '#000';

                } else if (styleType === 'underline') {
                    span.classList.add('underlined');
                    span.style.textDecorationColor = color;
                }
                range.surroundContents(span);

                highlightsMap.set(id, {
                    text: highlightText,
                    color,
                    styleType
                    //startOffset: startIndex,
                    //endOffset: startIndex + highlightText.length
                });
                
            }
        });
    }

    function getSelectionRange() {
        const selection = window.getSelection();
        if (selection.rangeCount > 0) {
            const range = selection.getRangeAt(0);
            if (contentParagraph.contains(range.commonAncestorContainer)) {
                return range;
            }
        }
        return null;
    }

    function applyColorToSelection(color) {
        if (!currentActiveStyledElement) return;
    
        const type = currentActiveStyledElement.dataset.styleType;
    
        if (type === 'highlight') {
            currentActiveStyledElement.style.backgroundColor = color;
            
            // Check luminance & set text color based on brightness
            const rgb = getRGB(color);
            const luminance = getLuminance(rgb.r, rgb.g, rgb.b);
    
            if (luminance < 0.5) {
                currentActiveStyledElement.style.color = '#fff';
            } else {
                currentActiveStyledElement.style.color = '#000';
            }
    
        } else if (type === 'underline') {
            currentActiveStyledElement.style.textDecorationColor = color;
            // DO NOT mess with text color for underline
        }
    
        currentActiveStyledElement.dataset.color = color;
    
        highlightsMap.set(currentActiveStyledElement.dataset.id, {
    text: currentActiveStyledElement.textContent,
    color: color,
    styleType: type
   // startOffset: getNodeOffset(currentActiveStyledElement),
//    endOffset: getNodeOffset(currentActiveStyledElement) + currentActiveStyledElement.textContent.length
});
saveHighlightsToStorage(highlightsMap);
    }

    function getBrightness(rgbString) {
        const [r, g, b] = rgbString.match(/\d+/g).map(Number);
        // Standard brightness formula
        return (r * 299 + g * 587 + b * 114) / 1000;
    }
    
    function getRGB(hex) {
        const cleanHex = hex.replace('#', '');
        const bigint = parseInt(cleanHex, 16);
        const r = (bigint >> 16) & 255;
        const g = (bigint >> 8) & 255;
        const b = bigint & 255;
        return { r, g, b };
    }

    function getLuminance(r, g, b) {
        const [R, G, B] = [r, g, b].map(c => {
            c /= 255;
            return c <= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
        });
        return 0.2126 * R + 0.7152 * G + 0.0722 * B;
    }

    function getContrastColor(hex) {
        // Convert hex to RGB
        let r = 0, g = 0, b = 0;
    
        if (hex.startsWith('#')) {
            hex = hex.slice(1);
        }
    
        if (hex.length === 3) {
            r = parseInt(hex[0] + hex[0], 16);
            g = parseInt(hex[1] + hex[1], 16);
            b = parseInt(hex[2] + hex[2], 16);
        } else if (hex.length === 6) {
            r = parseInt(hex.substring(0, 2), 16);
            g = parseInt(hex.substring(2, 4), 16);
            b = parseInt(hex.substring(4, 6), 16);
        }
    
        // Calculate luminance
        const luminance = 0.299 * r + 0.587 * g + 0.114 * b;
    
        // Use white for dark backgrounds, black for light ones
        return luminance < 128 ? '#fff' : '#000';
    }

    function showToolbar(target, isEditMode = false, x = null, y = null) {
        const range = getSelectionRange();
    
        let rect;
    
        if (isEditMode && target) {
            rect = target.getBoundingClientRect();
            x = x ?? rect.left + rect.width / 2;
            y = y ?? rect.top;
        
        } else if (range) {
            rect = range.getBoundingClientRect();
            x = x || rect.left + (rect.width / 2);
            y = y || rect.top;
            
        } else {
            hideToolbar();
            return;
        }

        applyHighlightBtn.classList.toggle('hidden', isEditMode);
        applyHighlightBtn.classList.toggle('visible', !isEditMode);
        applyUnderlineBtn.classList.toggle('hidden', isEditMode);
        applyUnderlineBtn.classList.toggle('visible', !isEditMode);
        
        copyBtn.classList.toggle('hidden', isEditMode);
        copyBtn.classList.toggle('visible', !isEditMode);
        
        deleteStyleBtn.classList.toggle('hidden', !isEditMode);
        deleteStyleBtn.classList.toggle('visible', isEditMode);
        colorPalette.classList.toggle('hidden', !isEditMode);
        colorPalette.classList.toggle('visible', isEditMode);
    
        // Temporarily show toolbar offscreen to measure it
        highlightToolbar.style.left = '-9999px'; //-9999px
        highlightToolbar.style.top = '-9999px';
        
        
        highlightToolbar.classList.remove('hidden');
        highlightToolbar.classList.add('visible');
         //aage ka code stop
        
        // Now that it's visible, we can accurately measure
        const toolbarWidth = highlightToolbar.offsetWidth;
        
        const toolbarHeight = highlightToolbar.offsetHeight;
        
        const containerRect = contentParagraph.getBoundingClientRect();
        const windowWidth = window.innerWidth;
        const windowHeight = window.innerHeight;
        const padding = 15;
    
        // X-axis positioning
        let toolbarLeft = x - (toolbarWidth / 2);
    
        toolbarLeft = Math.max(padding, Math.min(toolbarLeft, windowWidth - toolbarWidth - padding));
    
        toolbarLeft -= containerRect.left;

        // Y-axis positioning
        let toolbarTop = rect.top - containerRect.top - toolbarHeight - padding;
        if (toolbarTop < padding - containerRect.top) {
            //niche jao
            toolbarTop = rect.bottom - containerRect.top + padding + 24;
        }

        const absoluteTop = containerRect.top + toolbarTop;
        if (absoluteTop + toolbarHeight + padding > windowHeight) {
            toolbarTop = windowHeight - containerRect.top - toolbarHeight - padding;
        }
        if (absoluteTop < padding) {
            toolbarTop = padding - containerRect.top;
        }

        // Final placement
        highlightToolbar.style.left = `${toolbarLeft}px`;
        highlightToolbar.style.top = `${toolbarTop}px`;
    
        // Button visibility
        applyHighlightBtn.classList.toggle('hidden', isEditMode);
        applyHighlightBtn.classList.toggle('visible', !isEditMode);
        applyUnderlineBtn.classList.toggle('hidden', isEditMode);
        applyUnderlineBtn.classList.toggle('visible', !isEditMode);
        
        copyBtn.classList.toggle('hidden', isEditMode);
        copyBtn.classList.toggle('visible', !isEditMode);
        
        deleteStyleBtn.classList.toggle('hidden', !isEditMode);
        deleteStyleBtn.classList.toggle('visible', isEditMode);
        colorPalette.classList.toggle('hidden', !isEditMode);
        colorPalette.classList.toggle('visible', isEditMode);
    }


    function hideToolbar() {
        highlightToolbar.classList.remove('visible');
        highlightToolbar.classList.add('hidden');
        if (currentActiveStyledElement) {
            currentActiveStyledElement.classList.remove('active');
            currentActiveStyledElement = null;
        }
    }

    function applyStyle(styleType) {
        const range = getSelectionRange();
        if (!range) return;
        hideToolbar();
        const selectedText = range.toString();
        const id = `highlight${Date.now()}`;
        const span = document.createElement('span');
    
        span.dataset.styleType = styleType;
        span.dataset.color = selectedColor;
        span.dataset.id = id;
    
        // Only handle background and text color for highlight
        if (styleType === 'highlight') {
            span.classList.add('highlighted');
            span.style.backgroundColor = selectedColor;
    
            // If highlight color is dark, switch text to white
            if (isColorDark(selectedColor)) {
                span.style.color = 'white';
            } else {
                span.style.color = 'black';
            }
    
        } else if (styleType === 'underline') {
            span.classList.add('underlined');
            span.style.textDecorationColor = selectedColor;
            span.style.color = 'inherit'; // Do NOT override text color for underline
        }
    
        try {
            range.surroundContents(span);
        } catch (e) {
            console.error("Could not surround contents:", e);
            if (selectedText) {
                const tempSpan = document.createElement('span');
                tempSpan.textContent = selectedText;
                tempSpan.dataset.styleType = styleType;
                tempSpan.dataset.color = selectedColor;
                tempSpan.dataset.id = id;
    
                if (styleType === 'highlight') {
                    tempSpan.classList.add('highlighted');
                    tempSpan.style.backgroundColor = selectedColor;
                    tempSpan.style.color = isColorDark(selectedColor) ? 'white' : 'black';
                } else if (styleType === 'underline') {
                    tempSpan.classList.add('underlined');
                    tempSpan.style.textDecorationColor = selectedColor;
                    tempSpan.style.color = 'inherit';
                }
    
                range.deleteContents();
                range.insertNode(tempSpan);
            }
        }
    
        highlightsMap.set(id, {
            text: selectedText,
            color: selectedColor,
            styleType
           // startOffset: getNodeOffset(span),
            // endOffset: getNodeOffset(span) + selectedText.length
        });
        saveHighlightsToStorage(highlightsMap);
        window.getSelection().removeAllRanges();
        hideToolbar();
    }

    function isColorDark(hex) {
        hex = hex.replace('#', '');
    
        // convert to RGB
        let r = parseInt(hex.substring(0, 2), 16);
        let g = parseInt(hex.substring(2, 4), 16);
        let b = parseInt(hex.substring(4, 6), 16);
    
        // Calculate luminance
        let luminance = (0.299 * r + 0.587 * g + 0.114 * b);
    
        return luminance < 160; // tweak threshold if needed
    }

    function deleteStyle() {
        if (!currentActiveStyledElement) return;
        const id = currentActiveStyledElement.dataset.id;
        const parent = currentActiveStyledElement.parentNode;
        while (currentActiveStyledElement.firstChild) {
            parent.insertBefore(currentActiveStyledElement.firstChild, currentActiveStyledElement);
        }
        parent.removeChild(currentActiveStyledElement);
        highlightsMap.delete(id);
        saveHighlightsToStorage(highlightsMap);
        hideToolbar();
    }

    function handleSelection(event) {
        setTimeout(() => {
            const selection = window.getSelection();
            const range = getSelectionRange();
            if (range && !selection.isCollapsed && contentParagraph.contains(range.commonAncestorContainer)) {
                if (currentActiveStyledElement) {
                    currentActiveStyledElement.classList.remove('active');
                    currentActiveStyledElement = null;
                }
                let x, y;
                if (event.type === 'touchend') {
                    const touch = event.changedTouches[0];
                    x = touch.clientX;
                    y = touch.clientY;
                } else {
                    x = event.clientX;
                    y = event.clientY;
                }
                showToolbar(range, false, x, y);
            } else {
                if (!currentActiveStyledElement) hideToolbar();
            }
        }, 50);
    }

    let isDragging = false;
    let dragOffsetX = 0;
    let dragOffsetY = 0;

    highlightToolbar.addEventListener('mousedown', (e) => {
        if (e.target.closest('button, .color-option')) return;
        e.preventDefault();
        isDragging = true;
        const rect = highlightToolbar.getBoundingClientRect();
        dragOffsetX = e.clientX - rect.left;
        dragOffsetY = e.clientY - rect.top;
    });

    document.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        e.preventDefault();
        const containerRect = contentParagraph.getBoundingClientRect();
        const windowWidth = window.innerWidth;
        const windowHeight = window.innerHeight;
        const toolbarWidth = highlightToolbar.offsetWidth;
        const toolbarHeight = highlightToolbar.offsetHeight;
        const padding = 15;

        let newLeft = e.clientX - dragOffsetX - containerRect.left;
        let newTop = e.clientY - dragOffsetY - containerRect.top;

        newLeft = Math.max(padding, Math.min(newLeft, windowWidth - toolbarWidth - padding - containerRect.left));
        newTop = Math.max(padding - containerRect.top, Math.min(newTop, windowHeight - toolbarHeight - padding - containerRect.top));

        highlightToolbar.style.left = `${newLeft}px`;
        highlightToolbar.style.top = `${newTop}px`;
    });

    document.addEventListener('mouseup', () => {
        isDragging = false;
    });

    highlightToolbar.addEventListener('touchstart', (e) => {
        if (e.target.closest('button, .color-option')) return;
        e.preventDefault();
        isDragging = true;
        const touch = e.touches[0];
        const rect = highlightToolbar.getBoundingClientRect();
        dragOffsetX = touch.clientX - rect.left;
        dragOffsetY = touch.clientY - rect.top;
    });

    document.addEventListener('touchmove', (e) => {
        if (!isDragging) return;
        e.preventDefault();
        const touch = e.touches[0];
        const containerRect = contentParagraph.getBoundingClientRect();
        const windowWidth = window.innerWidth;
        const windowHeight = window.innerHeight;
        const toolbarWidth = highlightToolbar.offsetWidth;
        const toolbarHeight = highlightToolbar.offsetHeight;
        const padding = 15;

        let newLeft = touch.clientX - dragOffsetX - containerRect.left;
        let newTop = touch.clientY - dragOffsetY - containerRect.top;

        newLeft = Math.max(padding, Math.min(newLeft, windowWidth - toolbarWidth - padding - containerRect.left));
        newTop = Math.max(padding - containerRect.top, Math.min(newTop, windowHeight - toolbarHeight - padding - containerRect.top));

        highlightToolbar.style.left = `${newLeft}px`;
        highlightToolbar.style.top = `${newTop}px`;
    });

    document.addEventListener('touchend', () => {
        isDragging = false;
    });

    populateColorPalette();
    applyPreHighlights();

    contentParagraph.addEventListener('mouseup', handleSelection);
    contentParagraph.addEventListener('touchend', handleSelection);
    contentParagraph.addEventListener('contextmenu', (event) => {
        event.preventDefault();
        handleSelection(event);
    });

    contentParagraph.addEventListener('click', (e) => {
        let target = e.target;
        while (target && target !== contentParagraph && !target.classList.contains('highlighted') && !target.classList.contains('underlined')) {
            target = target.parentNode;
        }
        if (target && (target.classList.contains('highlighted') || target.classList.contains('underlined'))) {
            if (currentActiveStyledElement && currentActiveStyledElement !== target) {
                currentActiveStyledElement.classList.remove('active');
            }
            currentActiveStyledElement = target;
            currentActiveStyledElement.classList.add('active');
            window.getSelection().removeAllRanges();
            showToolbar(currentActiveStyledElement, true);
        } else {
            hideToolbar();
        }
    });

    highlightToolbar.addEventListener('mousedown', (e) => {
        if (e.target.closest('button, .color-option')) e.preventDefault();
    });

    applyHighlightBtn.addEventListener('click', () => applyStyle('highlight'));
    copyBtn.addEventListener('click', () => {
    const selection = window.getSelection();
    const selectedText = selection.toString();

    if (selectedText.trim() !== "") {
        try {
            navigator.clipboard.writeText(selectedText).then(() => {
                console.log("Text copied to clipboard");
            }).catch(err => {
                console.error("Failed to copy: ", err);
            });
        } catch (err) {
            console.error("Clipboard access error: ", err);
        }
    }

    selection.removeAllRanges();
    hideToolbar();
});

        applyUnderlineBtn.addEventListener('click', () => applyStyle('underline'));
        deleteStyleBtn.addEventListener('click', deleteStyle);

        window.addEventListener('resize', () => {
            if (highlightToolbar.classList.contains('visible')) {
                if (currentActiveStyledElement) {
                    showToolbar(currentActiveStyledElement, true);
                } else {
                    const range = getSelectionRange();
                    if (range) showToolbar(range, false);
                    else hideToolbar();
                }
            }
        });
        
        document.addEventListener('keydown', function(e) {
            // CTRL + U
            if (e.ctrlKey && e.key.toLowerCase() === 'u') {
                e.preventDefault(); // stop browser default action
                applyStyle('underline');
                // Your custom function here
            }
            
            // DELETE
            if (e.key === 'Delete') {
                deleteStyle();
                
            }
            
            // CTRL + SPACE
            if (e.ctrlKey && e.code === 'Space') {
                e.preventDefault();
                applyStyle('highlight');
            }
        });
    </script>
</body>
</html>